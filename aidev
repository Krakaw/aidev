#!/usr/bin/env bash
#
# aidev - AI-powered parallel development with git worktrees and tmux
#
# Usage: aidev <command> [options]
#
# Commands:
#   new <feature>     Create a new worktree, window, and launch AI tool
#   list              List all active feature sessions
#   attach [feature]  Attach to an existing feature session (fzf if not specified)
#   cd [feature]      Print worktree path for cd (fzf if not specified)
#   cleanup [feature] Remove worktree and close window (fzf if not specified)
#   cleanup-all       Remove all worktrees and close all feature windows
#

set -euo pipefail

# Configuration (can be overridden via environment variables)
AIDEV_TOOL="${AIDEV_TOOL:-opencode}"           # AI tool to launch (opencode, amp, claude, etc.)
AIDEV_BASE_BRANCH="${AIDEV_BASE_BRANCH:-main}" # Base branch for new worktrees
AIDEV_WORKTREE_DIR="${AIDEV_WORKTREE_DIR:-}"   # Custom worktree directory (default: ../<repo>-worktrees)
AIDEV_SESSION_NAME="${AIDEV_SESSION_NAME:-}"   # Base tmux session name (default: aidev-<repo>)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
info() { echo -e "${BLUE}[info]${NC} $*"; }
success() { echo -e "${GREEN}[ok]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
error() { echo -e "${RED}[error]${NC} $*" >&2; }

# Get the git root directory (main repo, not worktree)
# When inside a worktree, this returns the main repository path
get_git_root() {
    local toplevel
    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || {
        error "Not in a git repository"
        exit 1
    }
    
    # Check if we're in a worktree by looking at the first line of 'git worktree list'
    # The first entry is always the main worktree (the original repo)
    local main_worktree
    main_worktree="$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')"
    
    if [[ -n "$main_worktree" ]]; then
        echo "$main_worktree"
    else
        echo "$toplevel"
    fi
}

# Get repository name from git root
get_repo_name() {
    basename "$(get_git_root)"
}

# Get the tmux session name for this repository
# If feature is provided, return session name for that specific worktree
get_session_name() {
    local feature="${1:-}"
    local base_name
    
    if [[ -n "$AIDEV_SESSION_NAME" ]]; then
        base_name="$AIDEV_SESSION_NAME"
    else
        base_name="aidev-$(get_repo_name)"
    fi
    
    if [[ -n "$feature" ]]; then
        echo "${base_name}-${feature}"
    else
        echo "$base_name"
    fi
}

# Get the worktree base directory
get_worktree_base() {
    if [[ -n "$AIDEV_WORKTREE_DIR" ]]; then
        echo "$AIDEV_WORKTREE_DIR"
    else
        local git_root
        git_root="$(get_git_root)"
        echo "$(dirname "$git_root")/$(get_repo_name)-worktrees"
    fi
}

# Construct worktree path for a new feature (does not check if it exists)
make_worktree_path() {
    local feature="$1"
    echo "$(get_worktree_base)/$feature"
}

# Get worktree path for a branch name (authoritative lookup from git)
# Only returns paths within the managed worktree directory
# Returns empty string if not found
get_worktree_path_for_branch() {
    local branch="$1"
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    git -C "$git_root" worktree list --porcelain 2>/dev/null \
    | awk -v want="$branch" -v wt_base="$worktree_base" '
        $1=="worktree" { wt=$2 }
        $1=="branch" {
          b=$2; sub("^refs/heads/","",b)
          if (b==want && index(wt, wt_base"/") == 1) { print wt; exit }
        }
      '
}

# Get list of managed branch/feature names (one per line)
get_managed_features() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    git -C "$git_root" worktree list --porcelain 2>/dev/null \
    | awk -v git_root="$git_root" -v wt_base="$worktree_base" '
        $1=="worktree" { wt=$2 }
        $1=="branch" {
          b=$2; sub("^refs/heads/","",b)
          if (wt != git_root && index(wt, wt_base"/") == 1) {
            print b
          }
        }
      '
}

# Select a feature using fzf, or fail if no features exist
# Usage: select_feature "prompt message"
# Returns: selected feature name on stdout, exits 1 if cancelled or no features
select_feature() {
    local prompt="${1:-Select a feature}"
    
    # Check if fzf is available
    if ! command -v fzf &>/dev/null; then
        error "fzf is required for interactive selection. Install it or provide a feature name."
        exit 1
    fi
    
    # Get list of features
    local features
    features="$(get_managed_features)"
    
    if [[ -z "$features" ]]; then
        error "No managed worktrees found."
        info "Use 'aidev new <feature-name>' to create one."
        exit 1
    fi
    
    # Let user select with fzf
    local selected
    selected="$(echo "$features" | fzf --prompt="$prompt: " --height=~50% --reverse)" || {
        error "No feature selected."
        exit 1
    }
    
    echo "$selected"
}

# Check if tmux session exists for a feature
session_exists() {
    local feature="${1:-}"
    tmux has-session -t "$(get_session_name "$feature")" 2>/dev/null
}

# Check if we're inside tmux
inside_multiplexer() {
    [[ -n "${TMUX:-}" ]]
}

# Attach to existing tmux session for a feature
attach_session() {
    local feature="${1:-}"
    tmux attach-session -t "$(get_session_name "$feature")"
}

# Create new tmux session for a feature and run command
create_session() {
    local full_cmd="$1"
    local workdir="$2"
    local feature="${3:-}"
    tmux new-session -s "$(get_session_name "$feature")" -c "$workdir" "$full_cmd"
}

# Create new tmux session for a feature (detached) and optionally run command
create_session_detached() {
    local workdir="$1"
    local feature="$2"
    local cmd="${3:-}"
    local session_name
    session_name="$(get_session_name "$feature")"
    
    if [[ -n "$cmd" ]]; then
        tmux new-session -d -s "$session_name" -c "$workdir" "$cmd"
    else
        tmux new-session -d -s "$session_name" -c "$workdir"
    fi
}

# Switch to or attach to a feature's session
switch_to_session() {
    local feature="$1"
    local session_name
    session_name="$(get_session_name "$feature")"
    
    if inside_multiplexer; then
        tmux switch-client -t "$session_name"
    else
        tmux attach-session -t "$session_name"
    fi
}

# Kill a feature's tmux session
kill_session() {
    local feature="$1"
    tmux kill-session -t "$(get_session_name "$feature")" 2>/dev/null || true
}

# Ensure we're running inside tmux, start/attach if not
# Uses a temporary "launcher" session to re-exec the command inside tmux
ensure_multiplexer() {
    # Already inside tmux, nothing to do
    if inside_multiplexer; then
        return 0
    fi
    
    # Use a launcher session name (base name without feature)
    local session_name
    session_name="$(get_session_name)-launcher"
    
    # Not inside tmux - need to start a session and re-exec
    info "Not running inside tmux, starting launcher session..."
    
    # Get the full command to re-execute
    local script_path
    script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    local full_cmd="$script_path $AIDEV_ORIGINAL_ARGS"
    local workdir
    workdir="$(pwd)"
    
    # Create or use launcher session to run the command
    if tmux has-session -t "$session_name" 2>/dev/null; then
        # Launcher session exists, create a new window for this command
        tmux new-window -a -t "$session_name" -c "$workdir" "$full_cmd"
        tmux attach-session -t "$session_name"
    else
        # Create new launcher session
        tmux new-session -s "$session_name" -c "$workdir" "$full_cmd"
    fi
    
    # If we get here, tmux has exited, so we should too
    exit 0
}

# Check if a worktree exists for a feature/branch
worktree_exists() {
    local feature="$1"
    [[ -n "$(get_worktree_path_for_branch "$feature")" ]]
}

# Send keys/command to a feature's tmux session
send_keys_to_session() {
    local feature="$1"
    local keys="$2"
    tmux send-keys -t "$(get_session_name "$feature")" "$keys" Enter
}

# Run pre-hook script if it exists
# Called after worktree creation, before window creation
# Arguments: worktree_path, feature_name, git_root
# Also exports: AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
run_pre_hook() {
    local worktree_path="$1"
    local feature="$2"
    local git_root="$3"
    
    local hook_file="$git_root/.aidev-pre"
    
    # No hook file, nothing to do
    if [[ ! -f "$hook_file" ]]; then
        return 0
    fi
    
    # Check if executable
    if [[ ! -x "$hook_file" ]]; then
        warn "Found .aidev-pre but it's not executable. Run: chmod +x .aidev-pre"
        return 0
    fi
    
    info "Running pre-hook script (.aidev-pre)..."
    echo ""
    
    # Export environment variables and run with positional args
    if AIDEV_WORKTREE_PATH="$worktree_path" \
       AIDEV_FEATURE_NAME="$feature" \
       AIDEV_GIT_ROOT="$git_root" \
       "$hook_file" "$worktree_path" "$feature" "$git_root"; then
        echo ""
        success "Pre-hook completed successfully"
        return 0
    else
        echo ""
        error "Pre-hook script failed (exit code: $?)"
        return 1
    fi
}

# Create a new feature worktree and session
cmd_new() {
    local feature="${1:-}"
    local base_branch="${2:-$AIDEV_BASE_BRANCH}"
    
    if [[ -z "$feature" ]]; then
        error "Usage: aidev new <feature-name> [base-branch]"
        exit 1
    fi
    
    local git_root session_name branch_name worktree_path
    git_root="$(get_git_root)"
    session_name="$(get_session_name "$feature")"
    branch_name="$feature"
    
    # Check if worktree already exists
    if worktree_exists "$feature"; then
        worktree_path="$(get_worktree_path_for_branch "$feature")"
        warn "Worktree already exists at $worktree_path"
        if session_exists "$feature"; then
            info "Switching to existing session..."
            switch_to_session "$feature"
            exit 0
        fi
    else
        # Construct path for new worktree
        worktree_path="$(make_worktree_path "$feature")"
        
        # Create worktree directory parent if needed
        mkdir -p "$(dirname "$worktree_path")"
        
        # Fetch latest from origin
        info "Fetching latest from origin..."
        git -C "$git_root" fetch origin "$base_branch" 2>/dev/null || true
        
        # Create new worktree with a new branch
        info "Creating worktree for '$feature' based on '$base_branch'..."
        if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch_name"; then
            # Branch exists, use it
            git -C "$git_root" worktree add "$worktree_path" "$branch_name"
        else
            # Create new branch from base
            git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "origin/$base_branch" 2>/dev/null || \
            git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "$base_branch"
        fi
        
        success "Created worktree at $worktree_path"
        
        # Run pre-hook if it exists
        if ! run_pre_hook "$worktree_path" "$feature" "$git_root"; then
            # Hook failed - ask user what to do
            echo ""
            read -p "Pre-hook failed. Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Cleaning up worktree..."
                git -C "$git_root" worktree remove --force "$worktree_path" 2>/dev/null || true
                error "Aborted."
                exit 1
            fi
            warn "Continuing despite hook failure..."
        fi
    fi
    
    # Create session if it doesn't exist
    if session_exists "$feature"; then
        info "Session '$session_name' already exists, switching to it..."
        switch_to_session "$feature"
    else
        info "Creating session '$session_name'..."
        create_session_detached "$worktree_path" "$feature"
        
        # Launch the AI tool
        info "Launching $AIDEV_TOOL..."
        send_keys_to_session "$feature" "$AIDEV_TOOL"
        
        success "Feature '$feature' is ready!"
        
        # Switch to the new session
        switch_to_session "$feature"
    fi
    
    echo ""
    info "Worktree: $worktree_path"
    info "Branch:   $branch_name"
    info "Session:  $session_name"
    info "AI Tool:  $AIDEV_TOOL"
}

# List all active feature sessions
cmd_list() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    echo ""
    echo "Active AI Development Sessions"
    echo "=============================="
    echo ""
    
    local found=false
    local wt_path="" wt_branch=""
    
    while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                wt_path="${line#worktree }"
                ;;
            branch\ *)
                wt_branch="${line#branch refs/heads/}"
                
                # Skip main worktree, only show managed ones
                if [[ "$wt_path" != "$git_root" && "$wt_path" == "$worktree_base"/* ]]; then
                    found=true
                    local feature="$wt_branch"
                    local session_name session_status
                    session_name="$(get_session_name "$feature")"
                    
                    if session_exists "$feature"; then
                        session_status="${GREEN}active${NC}"
                    else
                        session_status="${YELLOW}no session${NC}"
                    fi
                    
                    echo -e "  ${BLUE}$feature${NC}"
                    echo -e "    Branch:   $wt_branch"
                    echo -e "    Path:     $wt_path"
                    echo -e "    Session:  $session_status"
                    echo ""
                fi
                wt_path="" wt_branch=""
                ;;
        esac
    done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null)
    
    if [[ "$found" == false ]]; then
        echo "  No active feature sessions."
        echo ""
        echo "  Start a new one with: aidev new <feature-name>"
    fi
    echo ""
}

# Attach to an existing feature session
cmd_attach() {
    # Ensure we're in tmux first (before fzf selection to avoid double prompt)
    ensure_multiplexer
    
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Attach to feature")"
    fi
    
    local session_name worktree_path
    session_name="$(get_session_name "$feature")"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    if session_exists "$feature"; then
        info "Switching to session '$session_name'..."
        switch_to_session "$feature"
    else
        info "Session doesn't exist, creating it..."
        create_session_detached "$worktree_path" "$feature"
        
        info "Launching $AIDEV_TOOL..."
        send_keys_to_session "$feature" "$AIDEV_TOOL"
        
        switch_to_session "$feature"
    fi
    
    success "Attached to '$feature'"
}

# Cleanup a feature (remove worktree and close session)
cmd_cleanup() {
    local feature="${1:-}"
    local force="${2:-}"
    
    # Handle --force as first argument
    if [[ "$feature" == "--force" ]] || [[ "$feature" == "-f" ]]; then
        force="$feature"
        feature=""
    fi
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Cleanup feature")"
    fi
    
    local git_root worktree_path session_name
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    session_name="$(get_session_name "$feature")"
    
    # Close session if it exists
    if session_exists "$feature"; then
        info "Closing session '$session_name'..."
        kill_session "$feature"
        success "Closed session"
    fi
    
    # Remove worktree if it exists
    if [[ -n "$worktree_path" ]]; then
        info "Removing worktree at $worktree_path..."
        if [[ "$force" == "--force" ]] || [[ "$force" == "-f" ]]; then
            git -C "$git_root" worktree remove --force "$worktree_path"
        else
            git -C "$git_root" worktree remove "$worktree_path" || {
                error "Worktree has uncommitted changes. Use 'aidev cleanup $feature --force' to force removal."
                exit 1
            }
        fi
        success "Removed worktree"
    else
        warn "No worktree found for '$feature'"
    fi
    
    success "Cleaned up '$feature'"
}

# Cleanup all features
cmd_cleanup_all() {
    local force="${1:-}"
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    warn "This will remove ALL aidev worktrees and sessions!"
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Aborted."
        exit 0
    fi
    
    local wt_path="" wt_branch=""
    
    while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                wt_path="${line#worktree }"
                ;;
            branch\ *)
                wt_branch="${line#branch refs/heads/}"
                
                # Skip main worktree, only clean managed ones
                if [[ "$wt_path" != "$git_root" && "$wt_path" == "$worktree_base"/* ]]; then
                    info "Cleaning up '$wt_branch'..."
                    cmd_cleanup "$wt_branch" "$force"
                fi
                wt_path="" wt_branch=""
                ;;
        esac
    done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null)
    
    success "All features cleaned up!"
}

# Print worktree path for cd (to be used with shell integration)
# Since a subprocess cannot change the parent shell's directory,
# this outputs the path to be used with: cd "$(aidev cd)"
# Or add a shell function: aidev() { if [[ "$1" == "cd" ]]; then shift; cd "$(command aidev cd "$@")"; else command aidev "$@"; fi; }
cmd_cd() {
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "cd to feature")" 2>/dev/null
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" || ! -d "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    # Output the path - shell integration will handle the actual cd
    echo "$worktree_path"
}

# Show help
cmd_help() {
    cat << 'EOF'
aidev - AI-powered parallel development with git worktrees and tmux

USAGE:
    aidev <command> [options]

COMMANDS:
    new|add <feature> [base-branch]   Create new worktree, session, and launch AI tool
    list                              List all active feature sessions
    attach [feature]                  Attach to an existing feature session
    cd [feature]                      Print worktree path (use: cd "$(aidev cd)")
    cleanup [feature] [--force]       Remove worktree and close session
    cleanup-all [--force]             Remove all worktrees and close all sessions
    help                              Show this help message

    For 'attach', 'cd', and 'cleanup', if no feature is specified, an interactive
    selector (fzf) will be shown to choose from existing worktrees.

ENVIRONMENT VARIABLES:
    AIDEV_TOOL           AI tool to launch (default: opencode)
    AIDEV_BASE_BRANCH    Base branch for new worktrees (default: main)
    AIDEV_WORKTREE_DIR   Custom worktree directory
    AIDEV_SESSION_NAME   Base tmux session name (default: aidev-<repo>)
                         Feature sessions are named: <base>-<feature>

EXAMPLES:
    # Start working on a new feature
    aidev new add-user-auth

    # Start a feature based on a different branch
    aidev new hotfix-login release/v2

    # List all active features
    aidev list

    # Switch to an existing feature (with fzf selection)
    aidev attach

    # Switch to a specific feature
    aidev attach add-user-auth

    # Change directory to a worktree (with fzf selection)
    cd "$(aidev cd)"

    # Change directory to a specific worktree
    cd "$(aidev cd add-user-auth)"

    # Clean up a feature (with fzf selection)
    aidev cleanup

    # Clean up a specific feature
    aidev cleanup add-user-auth

    # Use a different AI tool
    AIDEV_TOOL=amp aidev new my-feature

SHELL INTEGRATION:
    To make 'aidev cd' change your shell's directory, add this to .bashrc/.zshrc:

        aidev() {
            if [[ "$1" == "cd" ]]; then
                shift
                local dir
                dir="$(command aidev cd "$@")" && cd "$dir"
            else
                command aidev "$@"
            fi
        }

    Then use: aidev cd [feature]

NOTES:
    This tool works from both the main repository and from within any
    worktree managed by aidev. Git operations always reference the main
    repository regardless of your current working directory.

HOOKS:
    .aidev-pre    Script run after worktree creation (before AI tool launch)
                  Place this file in your repository root (can be .gitignored)
                  
                  Arguments passed to the script:
                    $1 = worktree path
                    $2 = feature/branch name  
                    $3 = git root (original repo)
                  
                  Environment variables also set:
                    AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
                  
                  Example .aidev-pre:
                    #!/usr/bin/env bash
                    cd "$1"
                    cp "$3/.env" .env 2>/dev/null
                    npm install

WORKFLOW:
    1. Navigate to your git repository (or any worktree managed by aidev)
    2. Run 'aidev new <feature>' to start working on a feature
       (creates a dedicated tmux session for that feature)
    3. The tool creates a worktree, runs .aidev-pre (if present), opens a session, and launches your AI tool
    4. Work on multiple features by running 'aidev new' for each (each gets its own session)
    5. Use 'aidev list' to see all active features
    6. Use 'aidev attach' to switch between features (fzf selection or specify name)
    7. When done, merge via git/GitHub and run 'aidev cleanup'

EOF
}

# Main entry point
main() {
    # Save original args for re-exec inside multiplexer (must be done before shifting)
    AIDEV_ORIGINAL_ARGS="${*}"
    
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        new|add)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        attach|a)
            cmd_attach "$@"
            ;;
        cd)
            cmd_cd "$@"
            ;;
        cleanup|clean|rm)
            cmd_cleanup "$@"
            ;;
        cleanup-all|clean-all|rm-all)
            cmd_cleanup_all "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            error "Unknown command: $cmd"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
