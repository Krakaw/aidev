#!/usr/bin/env bash
#
# aidev - AI-powered parallel development with git worktrees and tmux
#
# Usage: aidev <command> [options]
#
# Commands:
#   new <feature>     Create a new worktree, window, and launch AI tool
#   list              List all active feature sessions
#   attach [feature]  Attach to an existing feature session (fzf if not specified)
#   status [feature]  Show detailed status of a feature (fzf if not specified)
#   cd [feature]      Print worktree path for cd (fzf if not specified)
#   git [feature] ... Run git commands in a feature's worktree (fzf if not specified)
#   pull [feature]    Update feature with latest from base branch
#   cleanup [feature] Remove worktree and close window (fzf if not specified)
#   cleanup-all       Remove all worktrees and close all feature windows
#

set -euo pipefail

# Configuration (can be overridden via environment variables)
AIDEV_TOOL="${AIDEV_TOOL:-opencode}"           # AI tool to launch (opencode, amp, claude, etc.)
AIDEV_BASE_BRANCH="${AIDEV_BASE_BRANCH:-}"     # Base branch for new worktrees (auto-detected if empty)
AIDEV_WORKTREE_DIR="${AIDEV_WORKTREE_DIR:-}"   # Custom worktree directory (default: ../<repo>-worktrees)
AIDEV_SESSION_NAME="${AIDEV_SESSION_NAME:-}"   # Base tmux session name (default: aidev-<repo>)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
info() { echo -e "${BLUE}[info]${NC} $*"; }
success() { echo -e "${GREEN}[ok]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
error() { echo -e "${RED}[error]${NC} $*" >&2; }

# Get the git root directory (main repo, not worktree)
# When inside a worktree, this returns the main repository path
get_git_root() {
    local toplevel
    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || {
        error "Not in a git repository"
        exit 1
    }
    
    # Check if we're in a worktree by looking at the first line of 'git worktree list'
    # The first entry is always the main worktree (the original repo)
    local main_worktree
    main_worktree="$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')"
    
    if [[ -n "$main_worktree" ]]; then
        echo "$main_worktree"
    else
        echo "$toplevel"
    fi
}

# Get the base branch for a feature (stored in git config when the worktree was created)
# Falls back to AIDEV_BASE_BRANCH if not found
get_base_branch_for_feature() {
    local feature="$1"
    local worktree_path="$2"
    
    # Try to get the base branch from git config (set when worktree was created)
    local base_branch
    base_branch="$(git -C "$worktree_path" config --local "branch.$feature.basebranch" 2>/dev/null || echo "")"
    
    if [[ -n "$base_branch" ]]; then
        echo "$base_branch"
    else
        # Fall back to AIDEV_BASE_BRANCH
        echo "$AIDEV_BASE_BRANCH"
    fi
}

# Get repository name from git root
get_repo_name() {
    basename "$(get_git_root)"
}

# Get the primary branch of the repository
# Checks origin/HEAD first, then falls back to common branch names
get_primary_branch() {
    local git_root
    git_root="$(get_git_root)"
    
    # If AIDEV_BASE_BRANCH is set, use it
    if [[ -n "$AIDEV_BASE_BRANCH" ]]; then
        echo "$AIDEV_BASE_BRANCH"
        return
    fi
    
    # Try to get the default branch from origin/HEAD
    local ref
    ref="$(git -C "$git_root" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)" && {
        echo "${ref#refs/remotes/origin/}"
        return
    }
    
    # Fallback: check for common primary branch names
    for branch in main master; do
        if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null || \
           git -C "$git_root" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            echo "$branch"
            return
        fi
    done
    
    # Last resort fallback
    echo "main"
}

# Get the tmux session name for this repository
# If feature is provided, return session name for that specific worktree
get_session_name() {
    local feature="${1:-}"
    local base_name
    
    if [[ -n "$AIDEV_SESSION_NAME" ]]; then
        base_name="$AIDEV_SESSION_NAME"
    else
        base_name="aidev-$(get_repo_name)"
    fi
    
    if [[ -n "$feature" ]]; then
        echo "${base_name}-${feature}"
    else
        echo "$base_name"
    fi
}

# Get the worktree base directory
get_worktree_base() {
    if [[ -n "$AIDEV_WORKTREE_DIR" ]]; then
        echo "$AIDEV_WORKTREE_DIR"
    else
        local git_root
        git_root="$(get_git_root)"
        echo "$(dirname "$git_root")/$(get_repo_name)-worktrees"
    fi
}

# Construct worktree path for a new feature (does not check if it exists)
make_worktree_path() {
    local feature="$1"
    echo "$(get_worktree_base)/$feature"
}

# Get worktree path for a branch name (authoritative lookup from git)
# Only returns paths within the managed worktree directory
# Returns empty string if not found
get_worktree_path_for_branch() {
    local branch="$1"
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    git -C "$git_root" worktree list --porcelain 2>/dev/null \
    | awk -v want="$branch" -v wt_base="$worktree_base" '
        $1=="worktree" { wt=$2 }
        $1=="branch" {
          b=$2; sub("^refs/heads/","",b)
          if (b==want && index(wt, wt_base"/") == 1) { print wt; exit }
        }
      '
}

# Get list of managed branch/feature names (one per line)
get_managed_features() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    git -C "$git_root" worktree list --porcelain 2>/dev/null \
    | awk -v git_root="$git_root" -v wt_base="$worktree_base" '
        $1=="worktree" { wt=$2 }
        $1=="branch" {
          b=$2; sub("^refs/heads/","",b)
          if (wt != git_root && index(wt, wt_base"/") == 1) {
            print b
          }
        }
      '
}

# Select a feature using fzf, or fail if no features exist
# Usage: select_feature "prompt message"
# Returns: selected feature name on stdout, exits 1 if cancelled or no features
select_feature() {
    local prompt="${1:-Select a feature}"
    
    # Check if fzf is available
    if ! command -v fzf &>/dev/null; then
        error "fzf is required for interactive selection. Install it or provide a feature name."
        exit 1
    fi
    
    # Get list of features
    local features
    features="$(get_managed_features)"
    
    if [[ -z "$features" ]]; then
        error "No managed worktrees found."
        info "Use 'aidev new <feature-name>' to create one."
        exit 1
    fi
    
    # Let user select with fzf
    local selected
    selected="$(echo "$features" | fzf --prompt="$prompt: " --height=~50% --reverse)" || {
        error "No feature selected."
        exit 1
    }
    
    echo "$selected"
}

# Check if tmux session exists for a feature
session_exists() {
    local feature="${1:-}"
    tmux has-session -t "$(get_session_name "$feature")" 2>/dev/null
}

# Check if we're inside tmux
inside_multiplexer() {
    [[ -n "${TMUX:-}" ]]
}

# Set iTerm2 tab title if running in iTerm2
set_iterm2_tab_title() {
    local title="$1"
    
    # Check for iTerm2 - LC_TERMINAL persists inside tmux, TERM_PROGRAM doesn't
    if [[ "${LC_TERMINAL:-}" == "iTerm2" || "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
        if [[ -n "${TMUX:-}" ]]; then
            # Inside tmux: enable passthrough and use iTerm2 proprietary sequence
            tmux set-option -p allow-passthrough on 2>/dev/null || true
            # Use iTerm2's SetUserVar or proprietary title sequence via passthrough
            printf '\033Ptmux;\033\033]0;%s\007\033\\' "$title"
        else
            # Outside tmux: use iTerm2 proprietary escape to set tab title
            # OSC 0 sets both window and tab title
            printf '\033]0;%s\007' "$title"
        fi
    fi
}

# Attach to existing tmux session for a feature
attach_session() {
    local feature="${1:-}"
    set_iterm2_tab_title "$feature"
    tmux attach-session -t "$(get_session_name "$feature")"
}

# Create new tmux session for a feature and run command
create_session() {
    local full_cmd="$1"
    local workdir="$2"
    local feature="${3:-}"
    tmux new-session -s "$(get_session_name "$feature")" -c "$workdir" \
        -e "AIDEV_TOOL=$AIDEV_TOOL" \
        -e "AIDEV_BASE_BRANCH=$AIDEV_BASE_BRANCH" \
        -e "AIDEV_WORKTREE_DIR=$AIDEV_WORKTREE_DIR" \
        -e "AIDEV_SESSION_NAME=$AIDEV_SESSION_NAME" \
        "$full_cmd"
}

# Create new tmux session for a feature (detached) and optionally run command
create_session_detached() {
    local workdir="$1"
    local feature="$2"
    local cmd="${3:-}"
    local session_name
    session_name="$(get_session_name "$feature")"
    
    if [[ -n "$cmd" ]]; then
        tmux new-session -d -s "$session_name" -c "$workdir" \
            -e "AIDEV_TOOL=$AIDEV_TOOL" \
            -e "AIDEV_BASE_BRANCH=$AIDEV_BASE_BRANCH" \
            -e "AIDEV_WORKTREE_DIR=$AIDEV_WORKTREE_DIR" \
            -e "AIDEV_SESSION_NAME=$AIDEV_SESSION_NAME" \
            "$cmd"
    else
        tmux new-session -d -s "$session_name" -c "$workdir" \
            -e "AIDEV_TOOL=$AIDEV_TOOL" \
            -e "AIDEV_BASE_BRANCH=$AIDEV_BASE_BRANCH" \
            -e "AIDEV_WORKTREE_DIR=$AIDEV_WORKTREE_DIR" \
            -e "AIDEV_SESSION_NAME=$AIDEV_SESSION_NAME"
    fi
    
    # Configure session for iTerm2 integration
    if [[ "${LC_TERMINAL:-}" == "iTerm2" || "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
        # Enable passthrough so escape sequences reach iTerm2
        tmux set-option -t "$session_name" allow-passthrough on 2>/dev/null || true
        # Set the window title to the feature name and enable title propagation
        tmux set-option -t "$session_name" set-titles on 2>/dev/null || true
        tmux set-option -t "$session_name" set-titles-string "$feature" 2>/dev/null || true
    fi
}

# Switch to or attach to a feature's session
switch_to_session() {
    local feature="$1"
    local session_name
    session_name="$(get_session_name "$feature")"
    
    # Configure tmux session for iTerm2 title propagation (also handles older sessions)
    if [[ "${LC_TERMINAL:-}" == "iTerm2" || "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
        tmux set-option -t "$session_name" allow-passthrough on 2>/dev/null || true
        tmux set-option -t "$session_name" set-titles on 2>/dev/null || true
        tmux set-option -t "$session_name" set-titles-string "$feature" 2>/dev/null || true
    fi
    
    # Set iTerm2 tab title directly as well
    set_iterm2_tab_title "$feature"
    
    if inside_multiplexer; then
        tmux switch-client -t "$session_name"
    else
        tmux attach-session -t "$session_name"
    fi
}

# Kill a feature's tmux session
kill_session() {
    local feature="$1"
    tmux kill-session -t "$(get_session_name "$feature")" 2>/dev/null || true
}

# Ensure we're running inside tmux, start/attach if not
# Uses a temporary "launcher" session to re-exec the command inside tmux
ensure_multiplexer() {
    # Already inside tmux, nothing to do
    if inside_multiplexer; then
        return 0
    fi
    
    # Use a launcher session name (base name without feature)
    local session_name
    session_name="$(get_session_name)-launcher"
    
    # Not inside tmux - need to start a session and re-exec
    info "Not running inside tmux, starting launcher session..."
    
    # Get the full command to re-execute
    local script_path
    script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    local full_cmd="$script_path $AIDEV_ORIGINAL_ARGS"
    local workdir
    workdir="$(pwd)"
    
    # Create or use launcher session to run the command
    if tmux has-session -t "$session_name" 2>/dev/null; then
        # Launcher session exists, create a new window for this command
        tmux new-window -a -t "$session_name" -c "$workdir" \
            -e "AIDEV_TOOL=$AIDEV_TOOL" \
            -e "AIDEV_BASE_BRANCH=$AIDEV_BASE_BRANCH" \
            -e "AIDEV_WORKTREE_DIR=$AIDEV_WORKTREE_DIR" \
            -e "AIDEV_SESSION_NAME=$AIDEV_SESSION_NAME" \
            "$full_cmd"
        tmux attach-session -t "$session_name"
    else
        # Create new launcher session
        tmux new-session -s "$session_name" -c "$workdir" \
            -e "AIDEV_TOOL=$AIDEV_TOOL" \
            -e "AIDEV_BASE_BRANCH=$AIDEV_BASE_BRANCH" \
            -e "AIDEV_WORKTREE_DIR=$AIDEV_WORKTREE_DIR" \
            -e "AIDEV_SESSION_NAME=$AIDEV_SESSION_NAME" \
            "$full_cmd"
    fi
    
    # If we get here, tmux has exited, so we should too
    exit 0
}

# Check if a worktree exists for a feature/branch
worktree_exists() {
    local feature="$1"
    [[ -n "$(get_worktree_path_for_branch "$feature")" ]]
}

# Send keys/command to a feature's tmux session
send_keys_to_session() {
    local feature="$1"
    local keys="$2"
    tmux send-keys -t "$(get_session_name "$feature")" "$keys" Enter
}

# Run pre-hook script if it exists
# Called after worktree creation, before window creation
# Arguments: worktree_path, feature_name, git_root
# Also exports: AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
run_pre_hook() {
    local worktree_path="$1"
    local feature="$2"
    local git_root="$3"
    
    local hook_file="$git_root/.aidev-pre"
    
    # No hook file, nothing to do
    if [[ ! -f "$hook_file" ]]; then
        return 0
    fi
    
    # Check if executable
    if [[ ! -x "$hook_file" ]]; then
        warn "Found .aidev-pre but it's not executable. Run: chmod +x .aidev-pre"
        return 0
    fi
    
    info "Running pre-hook script (.aidev-pre)..."
    echo ""
    
    # Export environment variables and run with positional args
    if AIDEV_WORKTREE_PATH="$worktree_path" \
       AIDEV_FEATURE_NAME="$feature" \
       AIDEV_GIT_ROOT="$git_root" \
       "$hook_file" "$worktree_path" "$feature" "$git_root"; then
        echo ""
        success "Pre-hook completed successfully"
        return 0
    else
        echo ""
        error "Pre-hook script failed (exit code: $?)"
        return 1
    fi
}

# Create a new feature worktree and session
cmd_new() {
    local feature="${1:-}"
    local base_branch="${2:-$(get_primary_branch)}"
    
    if [[ -z "$feature" ]]; then
        error "Usage: aidev new <feature-name> [base-branch]"
        exit 1
    fi
    
    local git_root session_name branch_name worktree_path
    git_root="$(get_git_root)"
    session_name="$(get_session_name "$feature")"
    branch_name="$feature"
    
    # Check if worktree already exists
    if worktree_exists "$feature"; then
        worktree_path="$(get_worktree_path_for_branch "$feature")"
        warn "Worktree already exists at $worktree_path"
        if session_exists "$feature"; then
            info "Switching to existing session..."
            switch_to_session "$feature"
            exit 0
        fi
    else
        # Construct path for new worktree
        worktree_path="$(make_worktree_path "$feature")"
        
        # Create worktree directory parent if needed
        mkdir -p "$(dirname "$worktree_path")"
        
        # Fetch latest from origin
        info "Fetching latest from origin..."
        git -C "$git_root" fetch origin "$base_branch" 2>/dev/null || true
        
        # Create new worktree with a new branch
         info "Creating worktree for '$feature' based on '$base_branch'..."
         if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch_name"; then
             # Branch exists, use it
             git -C "$git_root" worktree add "$worktree_path" "$branch_name"
         else
             # Create new branch from base
             git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "origin/$base_branch" 2>/dev/null || \
             git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "$base_branch"
         fi
         
         # Store the base branch in git config for this branch so we can use it later
         git -C "$worktree_path" config --local "branch.$branch_name.basebranch" "$base_branch"
         
         success "Created worktree at $worktree_path"
        
        # Run pre-hook if it exists
        if ! run_pre_hook "$worktree_path" "$feature" "$git_root"; then
            # Hook failed - ask user what to do
            echo ""
            read -p "Pre-hook failed. Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Cleaning up worktree..."
                git -C "$git_root" worktree remove --force "$worktree_path" 2>/dev/null || true
                error "Aborted."
                exit 1
            fi
            warn "Continuing despite hook failure..."
        fi
    fi
    
    # Create session if it doesn't exist
    if session_exists "$feature"; then
        info "Session '$session_name' already exists, switching to it..."
        switch_to_session "$feature"
    else
        info "Creating session '$session_name'..."
        create_session_detached "$worktree_path" "$feature"
        
        # Launch the AI tool
        info "Launching $AIDEV_TOOL..."
        send_keys_to_session "$feature" "$AIDEV_TOOL"
        
        success "Feature '$feature' is ready!"
        
        # Switch to the new session
        switch_to_session "$feature"
    fi
    
    echo ""
    info "Worktree: $worktree_path"
    info "Branch:   $branch_name"
    info "Session:  $session_name"
    info "AI Tool:  $AIDEV_TOOL"
}

# List all active feature sessions
cmd_list() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    echo ""
    echo "Active AI Development Sessions"
    echo "=============================="
    echo ""
    
    local found=false
    local wt_path="" wt_branch=""
    
    while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                wt_path="${line#worktree }"
                ;;
            branch\ *)
                wt_branch="${line#branch refs/heads/}"
                
                # Skip main worktree, only show managed ones
                if [[ "$wt_path" != "$git_root" && "$wt_path" == "$worktree_base"/* ]]; then
                    found=true
                    local feature="$wt_branch"
                    local session_name session_status
                    session_name="$(get_session_name "$feature")"
                    
                    if session_exists "$feature"; then
                        session_status="${GREEN}active${NC}"
                    else
                        session_status="${YELLOW}no session${NC}"
                    fi
                    
                    echo -e "  ${BLUE}$feature${NC}"
                    echo -e "    Branch:   $wt_branch"
                    echo -e "    Path:     $wt_path"
                    echo -e "    Session:  $session_status"
                    echo ""
                fi
                wt_path="" wt_branch=""
                ;;
        esac
    done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null)
    
    if [[ "$found" == false ]]; then
        echo "  No active feature sessions."
        echo ""
        echo "  Start a new one with: aidev new <feature-name>"
    fi
    echo ""
}

# Attach to an existing feature session
cmd_attach() {
    # Ensure we're in tmux first (before fzf selection to avoid double prompt)
    ensure_multiplexer
    
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Attach to feature")"
    fi
    
    local session_name worktree_path
    session_name="$(get_session_name "$feature")"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    if session_exists "$feature"; then
        info "Switching to session '$session_name'..."
        switch_to_session "$feature"
    else
        info "Session doesn't exist, creating it..."
        create_session_detached "$worktree_path" "$feature"
        
        info "Launching $AIDEV_TOOL..."
        send_keys_to_session "$feature" "$AIDEV_TOOL"
        
        switch_to_session "$feature"
    fi
    
    success "Attached to '$feature'"
}

# Cleanup a feature (remove worktree and close session)
cmd_cleanup() {
    local feature="${1:-}"
    local force="${2:-}"
    
    # Handle --force as first argument
    if [[ "$feature" == "--force" ]] || [[ "$feature" == "-f" ]]; then
        force="$feature"
        feature=""
    fi
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Cleanup feature")"
    fi
    
    local git_root worktree_path session_name
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    session_name="$(get_session_name "$feature")"
    
    # Close session if it exists
    if session_exists "$feature"; then
        info "Closing session '$session_name'..."
        kill_session "$feature"
        success "Closed session"
    fi
    
    # Remove worktree if it exists
    if [[ -n "$worktree_path" ]]; then
        info "Removing worktree at $worktree_path..."
        if [[ "$force" == "--force" ]] || [[ "$force" == "-f" ]]; then
            git -C "$git_root" worktree remove --force "$worktree_path"
        else
            git -C "$git_root" worktree remove "$worktree_path" || {
                error "Worktree has uncommitted changes. Use 'aidev cleanup $feature --force' to force removal."
                exit 1
            }
        fi
        success "Removed worktree"
    else
        warn "No worktree found for '$feature'"
    fi
    
    success "Cleaned up '$feature'"
}

# Cleanup all features
cmd_cleanup_all() {
    local force="${1:-}"
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    warn "This will remove ALL aidev worktrees and sessions!"
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Aborted."
        exit 0
    fi
    
    local wt_path="" wt_branch=""
    
    while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                wt_path="${line#worktree }"
                ;;
            branch\ *)
                wt_branch="${line#branch refs/heads/}"
                
                # Skip main worktree, only clean managed ones
                if [[ "$wt_path" != "$git_root" && "$wt_path" == "$worktree_base"/* ]]; then
                    info "Cleaning up '$wt_branch'..."
                    cmd_cleanup "$wt_branch" "$force"
                fi
                wt_path="" wt_branch=""
                ;;
        esac
    done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null)
    
    success "All features cleaned up!"
}

# Print worktree path for cd (to be used with shell integration)
# Since a subprocess cannot change the parent shell's directory,
# this outputs the path to be used with: cd "$(aidev cd)"
# Or add a shell function: aidev() { if [[ "$1" == "cd" ]]; then shift; cd "$(command aidev cd "$@")"; else command aidev "$@"; fi; }
cmd_cd() {
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "cd to feature")" 2>/dev/null
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" || ! -d "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    # Output the path - shell integration will handle the actual cd
    echo "$worktree_path"
}

# Show detailed status of a specific feature
cmd_status() {
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Status of feature")"
    fi
    
    local git_root worktree_path session_name
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    session_name="$(get_session_name "$feature")"
    
    if [[ -z "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    echo ""
    echo -e "${BLUE}Feature Status: $feature${NC}"
    echo "======================================"
    echo ""
    
    # Basic info
    echo -e "  ${GREEN}Worktree:${NC}  $worktree_path"
    echo -e "  ${GREEN}Branch:${NC}    $feature"
    echo -e "  ${GREEN}Session:${NC}   $session_name"
    
    # Session status
    if session_exists "$feature"; then
        echo -e "  ${GREEN}Status:${NC}    ${GREEN}active${NC}"
    else
        echo -e "  ${GREEN}Status:${NC}    ${YELLOW}no session${NC}"
    fi
    echo ""
    
    # Git status
    echo -e "  ${BLUE}Git Status:${NC}"
    local git_status
    git_status="$(git -C "$worktree_path" status --porcelain 2>/dev/null)"
    if [[ -z "$git_status" ]]; then
        echo -e "    ${GREEN}Clean working directory${NC}"
    else
        local modified added deleted untracked
        modified=$(echo "$git_status" | grep -c '^ M\|^M ' 2>/dev/null || echo 0)
        added=$(echo "$git_status" | grep -c '^A \|^AM' 2>/dev/null || echo 0)
        deleted=$(echo "$git_status" | grep -c '^ D\|^D ' 2>/dev/null || echo 0)
        untracked=$(echo "$git_status" | grep -c '^??' 2>/dev/null || echo 0)
        
        [[ $modified -gt 0 ]] && echo -e "    ${YELLOW}Modified:${NC}   $modified files"
        [[ $added -gt 0 ]] && echo -e "    ${GREEN}Added:${NC}      $added files"
        [[ $deleted -gt 0 ]] && echo -e "    ${RED}Deleted:${NC}    $deleted files"
        [[ $untracked -gt 0 ]] && echo -e "    ${BLUE}Untracked:${NC}  $untracked files"
    fi
    echo ""
    
    # Commits ahead/behind
    echo -e "  ${BLUE}Branch Comparison:${NC}"
    local ahead behind base_ref upstream_ref
    # Prefer the branch's upstream (e.g., origin/release/v2) if configured, otherwise fall back to origin/$AIDEV_BASE_BRANCH
    upstream_ref="$(git -C "$worktree_path" rev-parse --abbrev-ref "$feature@{upstream}" 2>/dev/null || echo "")"
    if [[ -n "$upstream_ref" ]]; then
        base_ref="$upstream_ref"
    else
        base_ref="origin/$AIDEV_BASE_BRANCH"
    fi
    ahead=$(git -C "$worktree_path" rev-list --count "$base_ref..$feature" 2>/dev/null || echo "?")
    behind=$(git -C "$worktree_path" rev-list --count "$feature..$base_ref" 2>/dev/null || echo "?")
    echo -e "    ${GREEN}Ahead:${NC}  $ahead commits from $base_ref"
    echo -e "    ${YELLOW}Behind:${NC} $behind commits from $base_ref"
    echo ""
    
    # Last commit
    echo -e "  ${BLUE}Last Commit:${NC}"
    local last_commit
    last_commit=$(git -C "$worktree_path" log -1 --format="    %h %s (%ar)" 2>/dev/null || echo "    (no commits)")
    echo "$last_commit"
    echo ""
}

# Run git command in the context of a feature's worktree
cmd_git() {
    local feature="${1:-}"
    
    # If first arg looks like a git command (and is not an existing feature), use fzf for feature
    if [[ -z "$feature" ]] || [[ "$feature" == -* ]] || { [[ -z "$(get_worktree_path_for_branch "$feature")" ]] && [[ "$feature" =~ ^(status|log|diff|show|branch|checkout|pull|push|fetch|commit|add|reset|stash|rebase|merge|cherry-pick)$ ]]; }; then
        # Put feature back in args if it was a git command
        if [[ -n "$feature" ]]; then
            set -- "$feature" "$@"
        fi
        feature="$(select_feature "Run git in feature")"
    else
        shift  # Remove feature from args
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    # Run git command in worktree context
    git -C "$worktree_path" "$@"
}

# Pull/rebase feature branch with latest from base branch
cmd_pull() {
    local feature="${1:-}"
    local rebase="${2:-}"
    
    # Handle --rebase as first argument
    if [[ "$feature" == "--rebase" ]] || [[ "$feature" == "-r" ]]; then
        rebase="$feature"
        feature=""
    fi
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Pull into feature")"
    fi
    
    local git_root worktree_path base_branch
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path_for_branch "$feature")"
    
    if [[ -z "$worktree_path" ]]; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    # Get the base branch for this feature (stored in config, or fall back to AIDEV_BASE_BRANCH)
    base_branch="$(get_base_branch_for_feature "$feature" "$worktree_path")"
    
    info "Fetching latest from origin..."
    if ! git -C "$worktree_path" fetch origin "$base_branch"; then
        error "Failed to fetch 'origin/$base_branch' for feature '$feature'."
        info "Please check your network connection and that the remote 'origin' and branch '$base_branch' exist."
        exit 1
    fi
    
    if [[ "$rebase" == "--rebase" ]] || [[ "$rebase" == "-r" ]]; then
        info "Rebasing '$feature' onto 'origin/$base_branch'..."
        if ! git -C "$worktree_path" rebase "origin/$base_branch"; then
            error "Rebase of '$feature' onto 'origin/$base_branch' failed."
            info "This is often due to merge conflicts. Run the following in the worktree to inspect and resolve:"
            info "  cd \"$worktree_path\""
            info "  git status   # See conflicted files"
            info "  # Resolve conflicts, then:"
            info "  git rebase --continue   # or 'git rebase --abort' to cancel"
            exit 1
        fi
    else
        info "Merging 'origin/$base_branch' into '$feature'..."
        if ! git -C "$worktree_path" merge "origin/$base_branch" --no-edit; then
            error "Merge of 'origin/$base_branch' into '$feature' failed."
            info "This is often due to merge conflicts. Run the following in the worktree to inspect and resolve:"
            info "  cd \"$worktree_path\""
            info "  git status   # See conflicted files"
            info "  # Resolve conflicts, then commit or abort the merge as appropriate:"
            info "  git merge --continue    # or 'git merge --abort' to cancel"
            exit 1
        fi
    fi
    
    success "Updated '$feature' with latest from '$base_branch'"
}

# Show help
cmd_help() {
    cat << 'EOF'
aidev - AI-powered parallel development with git worktrees and tmux

USAGE:
    aidev <command> [options]

COMMANDS:
    new|add <feature> [base-branch]   Create new worktree, session, and launch AI tool
    list|ls                           List all active feature sessions
    attach|a [feature]                Attach to an existing feature session
    status|st [feature]               Show detailed status of a feature
    cd [feature]                      Print worktree path (use: cd "$(aidev cd)")
    git|g [feature] <git-args>        Run git command in feature's worktree
    pull|update [feature] [--rebase]  Update feature with latest from base branch
    cleanup|clean|rm [feature]        Remove worktree and close session
    cleanup-all|clean-all|rm-all      Remove all worktrees and close all sessions
    help                              Show this help message

    For 'attach', 'cd', 'status', 'git', 'pull', and 'cleanup', if no feature is
    specified, an interactive selector (fzf) will be shown to choose from
    existing worktrees.

ENVIRONMENT VARIABLES:
    AIDEV_TOOL           AI tool to launch (default: opencode)
    AIDEV_BASE_BRANCH    Base branch for new worktrees (auto-detected from origin/HEAD)
    AIDEV_WORKTREE_DIR   Custom worktree directory
    AIDEV_SESSION_NAME   Base tmux session name (default: aidev-<repo>)
                         Feature sessions are named: <base>-<feature>

EXAMPLES:
    # Start working on a new feature
    aidev new add-user-auth

    # Start a feature based on a different branch
    aidev new hotfix-login release/v2

    # List all active features
    aidev list

    # View detailed status of a feature (with fzf selection)
    aidev status

    # View status of a specific feature
    aidev status add-user-auth

    # Switch to an existing feature (with fzf selection)
    aidev attach

    # Switch to a specific feature
    aidev attach add-user-auth

    # Run git commands in a feature's worktree (with fzf selection)
    aidev git status
    aidev git log --oneline -5

    # Run git commands in a specific feature's worktree
    aidev git add-user-auth status
    aidev git add-user-auth diff

    # Update a feature with latest changes from base branch
    aidev pull                    # merge (fzf selection)
    aidev pull add-user-auth      # merge specific feature
    aidev pull --rebase           # rebase (fzf selection)
    aidev pull add-user-auth -r   # rebase specific feature

    # Change directory to a worktree (with fzf selection)
    cd "$(aidev cd)"

    # Change directory to a specific worktree
    cd "$(aidev cd add-user-auth)"

    # Clean up a feature (with fzf selection)
    aidev cleanup

    # Clean up a specific feature
    aidev cleanup add-user-auth

    # Use a different AI tool
    AIDEV_TOOL=amp aidev new my-feature

SHELL INTEGRATION:
    To make 'aidev cd' change your shell's directory, add this to .bashrc/.zshrc:

        aidev() {
            if [[ "$1" == "cd" ]]; then
                shift
                local dir
                dir="$(command aidev cd "$@")" && cd "$dir"
            else
                command aidev "$@"
            fi
        }

    Then use: aidev cd [feature]

NOTES:
    This tool works from both the main repository and from within any
    worktree managed by aidev. Git operations always reference the main
    repository regardless of your current working directory.

HOOKS:
    .aidev-pre    Script run after worktree creation (before AI tool launch)
                  Place this file in your repository root (can be .gitignored)
                  
                  Arguments passed to the script:
                    $1 = worktree path
                    $2 = feature/branch name  
                    $3 = git root (original repo)
                  
                  Environment variables also set:
                    AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
                  
                  Example .aidev-pre:
                    #!/usr/bin/env bash
                    cd "$1"
                    cp "$3/.env" .env 2>/dev/null
                    npm install

WORKFLOW:
    1. Navigate to your git repository (or any worktree managed by aidev)
    2. Run 'aidev new <feature>' to start working on a feature
       (creates a dedicated tmux session for that feature)
    3. The tool creates a worktree, runs .aidev-pre (if present), opens a session, and launches your AI tool
    4. Work on multiple features by running 'aidev new' for each (each gets its own session)
    5. Use 'aidev list' to see all active features
    6. Use 'aidev attach' to switch between features (fzf selection or specify name)
    7. When done, merge via git/GitHub and run 'aidev cleanup'

EOF
}

# Main entry point
main() {
    # Save original args for re-exec inside multiplexer (must be done before shifting)
    AIDEV_ORIGINAL_ARGS="${*}"
    
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        new|add)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        attach|a)
            cmd_attach "$@"
            ;;
        status|st)
            cmd_status "$@"
            ;;
        cd)
            cmd_cd "$@"
            ;;
        git|g)
            cmd_git "$@"
            ;;
        pull|update)
            cmd_pull "$@"
            ;;
        cleanup|clean|rm)
            cmd_cleanup "$@"
            ;;
        cleanup-all|clean-all|rm-all)
            cmd_cleanup_all "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            error "Unknown command: $cmd"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
