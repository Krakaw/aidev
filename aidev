#!/usr/bin/env bash
#
# aidev - AI-powered parallel development with git worktrees and tmux
#
# Usage: aidev <command> [options]
#
# Commands:
#   new <feature>     Create a new worktree, window, and launch AI tool
#   list              List all active feature sessions
#   attach [feature]  Attach to an existing feature session (fzf if not specified)
#   cd [feature]      Print worktree path for cd (fzf if not specified)
#   cleanup [feature] Remove worktree and close window (fzf if not specified)
#   cleanup-all       Remove all worktrees and close all feature windows
#

set -euo pipefail

# Configuration (can be overridden via environment variables)
AIDEV_TOOL="${AIDEV_TOOL:-opencode}"           # AI tool to launch (opencode, amp, claude, etc.)
AIDEV_BASE_BRANCH="${AIDEV_BASE_BRANCH:-main}" # Base branch for new worktrees
AIDEV_WORKTREE_DIR="${AIDEV_WORKTREE_DIR:-}"   # Custom worktree directory (default: ../<repo>-worktrees)
AIDEV_SESSION_PREFIX="${AIDEV_SESSION_PREFIX:-aidev}" # Prefix for window names
AIDEV_SESSION_NAME="${AIDEV_SESSION_NAME:-aidev}"     # Session name
AIDEV_MULTIPLEXER="${AIDEV_MULTIPLEXER:-screen}"      # Terminal multiplexer: screen or tmux

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
info() { echo -e "${BLUE}[info]${NC} $*"; }
success() { echo -e "${GREEN}[ok]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
error() { echo -e "${RED}[error]${NC} $*" >&2; }

# Get the git root directory (main repo, not worktree)
# When inside a worktree, this returns the main repository path
get_git_root() {
    local toplevel
    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || {
        error "Not in a git repository"
        exit 1
    }
    
    # Check if we're in a worktree by looking at the first line of 'git worktree list'
    # The first entry is always the main worktree (the original repo)
    local main_worktree
    main_worktree="$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')"
    
    if [[ -n "$main_worktree" ]]; then
        echo "$main_worktree"
    else
        echo "$toplevel"
    fi
}

# Get repository name from git root
get_repo_name() {
    basename "$(get_git_root)"
}

# Get the worktree base directory
get_worktree_base() {
    if [[ -n "$AIDEV_WORKTREE_DIR" ]]; then
        echo "$AIDEV_WORKTREE_DIR"
    else
        local git_root
        git_root="$(get_git_root)"
        echo "$(dirname "$git_root")/$(get_repo_name)-worktrees"
    fi
}

# Get worktree path for a feature
get_worktree_path() {
    local feature="$1"
    echo "$(get_worktree_base)/$feature"
}

# Get window name for a feature
get_window_name() {
    local feature="$1"
    echo "${AIDEV_SESSION_PREFIX}-${feature}"
}

# Get list of managed feature names (one per line)
get_managed_features() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    while IFS= read -r line; do
        local wt_path
        wt_path="$(echo "$line" | awk '{print $1}')"
        
        # Skip the main worktree
        if [[ "$wt_path" == "$git_root" ]]; then
            continue
        fi
        
        # Only show worktrees in our managed directory
        if [[ "$wt_path" == "$worktree_base"/* ]]; then
            basename "$wt_path"
        fi
    done < <(git -C "$git_root" worktree list 2>/dev/null)
}

# Select a feature using fzf, or fail if no features exist
# Usage: select_feature "prompt message"
# Returns: selected feature name on stdout, exits 1 if cancelled or no features
select_feature() {
    local prompt="${1:-Select a feature}"
    
    # Check if fzf is available
    if ! command -v fzf &>/dev/null; then
        error "fzf is required for interactive selection. Install it or provide a feature name."
        exit 1
    fi
    
    # Get list of features
    local features
    features="$(get_managed_features)"
    
    if [[ -z "$features" ]]; then
        error "No managed worktrees found."
        info "Use 'aidev new <feature-name>' to create one."
        exit 1
    fi
    
    # Let user select with fzf
    local selected
    selected="$(echo "$features" | fzf --prompt="$prompt: " --height=~50% --reverse)" || {
        error "No feature selected."
        exit 1
    }
    
    echo "$selected"
}

# Check if multiplexer session exists
session_exists() {
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -list 2>/dev/null | grep -q "\.${AIDEV_SESSION_NAME}[[:space:]]"
            ;;
        tmux)
            tmux has-session -t "$AIDEV_SESSION_NAME" 2>/dev/null
            ;;
        *)
            error "Unknown multiplexer: $AIDEV_MULTIPLEXER (use 'screen' or 'tmux')"
            exit 1
            ;;
    esac
}

# Check if we're inside the multiplexer
inside_multiplexer() {
    case "$AIDEV_MULTIPLEXER" in
        screen)
            [[ -n "${STY:-}" ]]
            ;;
        tmux)
            [[ -n "${TMUX:-}" ]]
            ;;
    esac
}

# Attach to existing session
attach_session() {
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -r "$AIDEV_SESSION_NAME"
            ;;
        tmux)
            tmux attach-session -t "$AIDEV_SESSION_NAME"
            ;;
    esac
}

# Create new session and run command
create_session() {
    local full_cmd="$1"
    local workdir="$2"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            # screen -c /dev/null avoids loading user's .screenrc which may cause issues
            screen -S "$AIDEV_SESSION_NAME" -c /dev/null bash -c "cd '$workdir' && $full_cmd; exec bash"
            ;;
        tmux)
            tmux new-session -s "$AIDEV_SESSION_NAME" -c "$workdir" "$full_cmd"
            ;;
    esac
}

# Create new window in session and run command
create_session_window() {
    local full_cmd="$1"
    local workdir="$2"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            # Create window and run command, then attach
            screen -S "$AIDEV_SESSION_NAME" -X screen bash -c "cd '$workdir' && $full_cmd; exec bash"
            screen -r "$AIDEV_SESSION_NAME"
            ;;
        tmux)
            tmux new-window -t "$AIDEV_SESSION_NAME" -c "$workdir" "$full_cmd"
            tmux attach-session -t "$AIDEV_SESSION_NAME"
            ;;
    esac
}

# Ensure we're running inside the multiplexer, start/attach if not
ensure_multiplexer() {
    # Already inside multiplexer, nothing to do
    if inside_multiplexer; then
        return 0
    fi
    
    # Not inside multiplexer - need to start or attach to session and re-exec
    info "Not running inside $AIDEV_MULTIPLEXER, starting session '$AIDEV_SESSION_NAME'..."
    
    # Get the full command to re-execute
    local script_path
    script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    local full_cmd="$script_path $AIDEV_ORIGINAL_ARGS"
    local workdir
    workdir="$(pwd)"
    
    if session_exists; then
        # Session exists, create a new window and run the command there
        info "Attaching to existing session..."
        create_session_window "$full_cmd" "$workdir"
    else
        # Create new session and run the command
        info "Creating new $AIDEV_MULTIPLEXER session..."
        create_session "$full_cmd" "$workdir"
    fi
    
    # If we get here, multiplexer has exited, so we should too
    exit 0
}

# Check if a worktree exists for a feature
worktree_exists() {
    local feature="$1"
    local worktree_path
    worktree_path="$(get_worktree_path "$feature")"
    [[ -d "$worktree_path" ]]
}

# Check if a window exists for a feature
window_exists() {
    local feature="$1"
    local window_name
    window_name="$(get_window_name "$feature")"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -S "$AIDEV_SESSION_NAME" -Q windows 2>/dev/null | grep -q "$window_name"
            ;;
        tmux)
            tmux list-windows -t "$AIDEV_SESSION_NAME" -F '#{window_name}' 2>/dev/null | grep -q "^${window_name}$"
            ;;
    esac
}

# Create a new window and optionally run a command
new_window() {
    local window_name="$1"
    local workdir="$2"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -S "$AIDEV_SESSION_NAME" -X screen -t "$window_name" bash -c "cd '$workdir'; exec bash"
            ;;
        tmux)
            tmux new-window -n "$window_name" -c "$workdir"
            ;;
    esac
}

# Select/focus a window
select_window() {
    local window_name="$1"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -S "$AIDEV_SESSION_NAME" -X select "$window_name"
            ;;
        tmux)
            tmux select-window -t "$window_name"
            ;;
    esac
}

# Send keys/command to a window
send_keys() {
    local window_name="$1"
    local keys="$2"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -S "$AIDEV_SESSION_NAME" -p "$window_name" -X stuff "$keys\n"
            ;;
        tmux)
            tmux send-keys -t "$window_name" "$keys" Enter
            ;;
    esac
}

# Kill/close a window
kill_window() {
    local window_name="$1"
    case "$AIDEV_MULTIPLEXER" in
        screen)
            screen -S "$AIDEV_SESSION_NAME" -p "$window_name" -X kill 2>/dev/null || true
            ;;
        tmux)
            tmux kill-window -t "$window_name" 2>/dev/null || true
            ;;
    esac
}

# Run pre-hook script if it exists
# Called after worktree creation, before window creation
# Arguments: worktree_path, feature_name, git_root
# Also exports: AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
run_pre_hook() {
    local worktree_path="$1"
    local feature="$2"
    local git_root="$3"
    
    local hook_file="$git_root/.aidev-pre"
    
    # No hook file, nothing to do
    if [[ ! -f "$hook_file" ]]; then
        return 0
    fi
    
    # Check if executable
    if [[ ! -x "$hook_file" ]]; then
        warn "Found .aidev-pre but it's not executable. Run: chmod +x .aidev-pre"
        return 0
    fi
    
    info "Running pre-hook script (.aidev-pre)..."
    echo ""
    
    # Export environment variables and run with positional args
    if AIDEV_WORKTREE_PATH="$worktree_path" \
       AIDEV_FEATURE_NAME="$feature" \
       AIDEV_GIT_ROOT="$git_root" \
       "$hook_file" "$worktree_path" "$feature" "$git_root"; then
        echo ""
        success "Pre-hook completed successfully"
        return 0
    else
        echo ""
        error "Pre-hook script failed (exit code: $?)"
        return 1
    fi
}

# Create a new feature worktree and window
cmd_new() {
    local feature="${1:-}"
    local base_branch="${2:-$AIDEV_BASE_BRANCH}"
    
    if [[ -z "$feature" ]]; then
        error "Usage: aidev new <feature-name> [base-branch]"
        exit 1
    fi
    
    ensure_multiplexer
    
    local git_root worktree_path window_name branch_name
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path "$feature")"
    window_name="$(get_window_name "$feature")"
    branch_name="$feature"
    
    # Check if worktree already exists
    if worktree_exists "$feature"; then
        warn "Worktree already exists at $worktree_path"
        if window_exists "$feature"; then
            info "Attaching to existing window..."
            select_window "$window_name"
            exit 0
        fi
    else
        # Create worktree directory parent if needed
        mkdir -p "$(dirname "$worktree_path")"
        
        # Fetch latest from origin
        info "Fetching latest from origin..."
        git -C "$git_root" fetch origin "$base_branch" 2>/dev/null || true
        
        # Create new worktree with a new branch
        info "Creating worktree for '$feature' based on '$base_branch'..."
        if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch_name"; then
            # Branch exists, use it
            git -C "$git_root" worktree add "$worktree_path" "$branch_name"
        else
            # Create new branch from base
            git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "origin/$base_branch" 2>/dev/null || \
            git -C "$git_root" worktree add -b "$branch_name" "$worktree_path" "$base_branch"
        fi
        
        success "Created worktree at $worktree_path"
        
        # Run pre-hook if it exists
        if ! run_pre_hook "$worktree_path" "$feature" "$git_root"; then
            # Hook failed - ask user what to do
            echo ""
            read -p "Pre-hook failed. Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Cleaning up worktree..."
                git -C "$git_root" worktree remove --force "$worktree_path" 2>/dev/null || true
                error "Aborted."
                exit 1
            fi
            warn "Continuing despite hook failure..."
        fi
    fi
    
    # Create window if it doesn't exist
    if window_exists "$feature"; then
        info "Window '$window_name' already exists, selecting it..."
        select_window "$window_name"
    else
        info "Creating window '$window_name'..."
        new_window "$window_name" "$worktree_path"
        
        # Launch the AI tool
        info "Launching $AIDEV_TOOL..."
        send_keys "$window_name" "$AIDEV_TOOL"
        
        success "Feature '$feature' is ready!"
    fi
    
    echo ""
    info "Worktree: $worktree_path"
    info "Branch:   $branch_name"
    info "Window:   $window_name"
    info "AI Tool:  $AIDEV_TOOL"
}

# List all active feature sessions
cmd_list() {
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    echo ""
    echo "Active AI Development Sessions"
    echo "=============================="
    echo ""
    
    # Get all worktrees for this repo
    local found=false
    while IFS= read -r line; do
        local wt_path wt_branch
        wt_path="$(echo "$line" | awk '{print $1}')"
        wt_branch="$(echo "$line" | awk '{print $3}' | tr -d '[]')"
        
        # Skip the main worktree
        if [[ "$wt_path" == "$git_root" ]]; then
            continue
        fi
        
        # Only show worktrees in our managed directory
        if [[ "$wt_path" == "$worktree_base"/* ]]; then
            found=true
            local feature window_name window_status
            feature="$(basename "$wt_path")"
            window_name="$(get_window_name "$feature")"
            
            if window_exists "$feature"; then
                window_status="${GREEN}active${NC}"
            else
                window_status="${YELLOW}no window${NC}"
            fi
            
            echo -e "  ${BLUE}$feature${NC}"
            echo -e "    Branch:  $wt_branch"
            echo -e "    Path:    $wt_path"
            echo -e "    Window:  $window_status"
            echo ""
        fi
    done < <(git -C "$git_root" worktree list)
    
    if [[ "$found" == false ]]; then
        echo "  No active feature sessions."
        echo ""
        echo "  Start a new one with: aidev new <feature-name>"
    fi
    echo ""
}

# Attach to an existing feature session
cmd_attach() {
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Attach to feature")"
    fi
    
    ensure_multiplexer
    
    local window_name worktree_path
    window_name="$(get_window_name "$feature")"
    worktree_path="$(get_worktree_path "$feature")"
    
    if ! worktree_exists "$feature"; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    if window_exists "$feature"; then
        info "Switching to window '$window_name'..."
        select_window "$window_name"
    else
        info "Window doesn't exist, creating it..."
        new_window "$window_name" "$worktree_path"
        
        info "Launching $AIDEV_TOOL..."
        send_keys "$window_name" "$AIDEV_TOOL"
    fi
    
    success "Attached to '$feature'"
}

# Cleanup a feature (remove worktree and close window)
cmd_cleanup() {
    local feature="${1:-}"
    local force="${2:-}"
    
    # Handle --force as first argument
    if [[ "$feature" == "--force" ]] || [[ "$feature" == "-f" ]]; then
        force="$feature"
        feature=""
    fi
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "Cleanup feature")"
    fi
    
    local git_root worktree_path window_name
    git_root="$(get_git_root)"
    worktree_path="$(get_worktree_path "$feature")"
    window_name="$(get_window_name "$feature")"
    
    # Close window if it exists
    if window_exists "$feature"; then
        info "Closing window '$window_name'..."
        kill_window "$window_name"
        success "Closed window"
    fi
    
    # Remove worktree if it exists
    if worktree_exists "$feature"; then
        info "Removing worktree at $worktree_path..."
        if [[ "$force" == "--force" ]] || [[ "$force" == "-f" ]]; then
            git -C "$git_root" worktree remove --force "$worktree_path"
        else
            git -C "$git_root" worktree remove "$worktree_path" || {
                error "Worktree has uncommitted changes. Use 'aidev cleanup $feature --force' to force removal."
                exit 1
            }
        fi
        success "Removed worktree"
    else
        warn "No worktree found for '$feature'"
    fi
    
    success "Cleaned up '$feature'"
}

# Cleanup all features
cmd_cleanup_all() {
    local force="${1:-}"
    local git_root worktree_base
    git_root="$(get_git_root)"
    worktree_base="$(get_worktree_base)"
    
    warn "This will remove ALL aidev worktrees and windows!"
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Aborted."
        exit 0
    fi
    
    # Find all worktrees in our managed directory
    while IFS= read -r line; do
        local wt_path
        wt_path="$(echo "$line" | awk '{print $1}')"
        
        # Skip the main worktree
        if [[ "$wt_path" == "$git_root" ]]; then
            continue
        fi
        
        # Only clean worktrees in our managed directory
        if [[ "$wt_path" == "$worktree_base"/* ]]; then
            local feature
            feature="$(basename "$wt_path")"
            info "Cleaning up '$feature'..."
            cmd_cleanup "$feature" "$force"
        fi
    done < <(git -C "$git_root" worktree list)
    
    success "All features cleaned up!"
}

# Print worktree path for cd (to be used with shell integration)
# Since a subprocess cannot change the parent shell's directory,
# this outputs the path to be used with: cd "$(aidev cd)"
# Or add a shell function: aidev() { if [[ "$1" == "cd" ]]; then shift; cd "$(command aidev cd "$@")"; else command aidev "$@"; fi; }
cmd_cd() {
    local feature="${1:-}"
    
    # If no feature provided, use fzf to select one
    if [[ -z "$feature" ]]; then
        feature="$(select_feature "cd to feature")" 2>/dev/null
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path "$feature")"
    
    if ! worktree_exists "$feature"; then
        error "No worktree found for feature '$feature'"
        info "Use 'aidev list' to see available features"
        exit 1
    fi
    
    # Output the path - shell integration will handle the actual cd
    echo "$worktree_path"
}

# Show help
cmd_help() {
    cat << 'EOF'
aidev - AI-powered parallel development with git worktrees and screen/tmux

USAGE:
    aidev <command> [options]

COMMANDS:
    new|add <feature> [base-branch]   Create new worktree, window, and launch AI tool
    list                              List all active feature sessions
    attach [feature]                  Attach to an existing feature session
    cd [feature]                      Print worktree path (for use with cd)
    cleanup [feature] [--force]       Remove worktree and close window
    cleanup-all [--force]             Remove all worktrees and close all windows
    help                              Show this help message

    For 'attach', 'cd', and 'cleanup', if no feature is specified, an interactive
    selector (fzf) will be shown to choose from existing worktrees.

ENVIRONMENT VARIABLES:
    AIDEV_TOOL           AI tool to launch (default: opencode)
    AIDEV_BASE_BRANCH    Base branch for new worktrees (default: main)
    AIDEV_WORKTREE_DIR   Custom worktree directory
    AIDEV_MULTIPLEXER    Terminal multiplexer: screen or tmux (default: screen)
    AIDEV_SESSION_NAME   Session name (default: aidev)
    AIDEV_SESSION_PREFIX Prefix for window names (default: aidev)

EXAMPLES:
    # Start working on a new feature
    aidev new add-user-auth

    # Start a feature based on a different branch
    aidev new hotfix-login release/v2

    # List all active features
    aidev list

    # Switch to an existing feature (with fzf selection)
    aidev attach

    # Switch to a specific feature
    aidev attach add-user-auth

    # Change directory to a worktree (with fzf selection)
    cd "$(aidev cd)"

    # Change directory to a specific worktree
    cd "$(aidev cd add-user-auth)"

    # Clean up a feature (with fzf selection)
    aidev cleanup

    # Clean up a specific feature
    aidev cleanup add-user-auth

    # Use a different AI tool
    AIDEV_TOOL=amp aidev new my-feature

    # Use tmux instead of screen
    AIDEV_MULTIPLEXER=tmux aidev new my-feature

SHELL INTEGRATION:
    To make 'aidev cd' change your shell's directory, add this to .bashrc/.zshrc:

        aidev() {
            if [[ "$1" == "cd" ]]; then
                shift
                local dir
                dir="$(command aidev cd "$@")" && cd "$dir"
            else
                command aidev "$@"
            fi
        }

    Then use: aidev cd [feature]

NOTES:
    This tool works from both the main repository and from within any
    worktree managed by aidev. Git operations always reference the main
    repository regardless of your current working directory.

HOOKS:
    .aidev-pre    Script run after worktree creation (before AI tool launch)
                  Place this file in your repository root (can be .gitignored)
                  
                  Arguments passed to the script:
                    $1 = worktree path
                    $2 = feature/branch name  
                    $3 = git root (original repo)
                  
                  Environment variables also set:
                    AIDEV_WORKTREE_PATH, AIDEV_FEATURE_NAME, AIDEV_GIT_ROOT
                  
                  Example .aidev-pre:
                    #!/usr/bin/env bash
                    cd "$1"
                    cp "$3/.env" .env 2>/dev/null
                    npm install

WORKFLOW:
    1. Navigate to your git repository (or any worktree managed by aidev)
    2. Run 'aidev new <feature>' to start working on a feature
       (screen/tmux session is started automatically if not already running)
    3. The tool creates a worktree, runs .aidev-pre (if present), opens a window, and launches your AI tool
    4. Work on multiple features by running 'aidev new' for each
    5. Use 'aidev list' to see all active features
    6. Use 'aidev attach' to switch between features (fzf selection or specify name)
    7. When done, merge via git/GitHub and run 'aidev cleanup'

EOF
}

# Main entry point
main() {
    # Save original args for re-exec inside multiplexer (must be done before shifting)
    AIDEV_ORIGINAL_ARGS="${*}"
    
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        new|add)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        attach|a)
            cmd_attach "$@"
            ;;
        cd)
            cmd_cd "$@"
            ;;
        cleanup|clean|rm)
            cmd_cleanup "$@"
            ;;
        cleanup-all|clean-all|rm-all)
            cmd_cleanup_all "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            error "Unknown command: $cmd"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
